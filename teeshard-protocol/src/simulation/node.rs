// teeshard-protocol/src/simulation/node.rs

use crate::{
    config::SystemConfig,
    data_structures::TEEIdentity,
    raft::{
        messages::RaftMessage,
        node::{RaftNode, RaftEvent},
        storage::InMemoryStorage, // Using InMemoryStorage for simulation
    },
    tee_logic::{crypto_sim::SecretKey, enclave_sim::EnclaveSim},
};
// Use crate::simulation::runtime::SimulationRuntime;
// Corrected import path assumption
use crate::simulation::runtime::SimulationRuntime;
use std::sync::Arc;
use tokio::sync::mpsc;
use tokio::time::{interval, Duration};

/// Represents a single TEE node within the simulation.
pub struct SimulatedTeeNode {
    pub identity: TEEIdentity,
    secret_key: SecretKey, // Keep the secret key for signing
    raft_node: RaftNode,
    // TODO: Add application-specific state for the shard if needed
    // state: ShardState,
    runtime: SimulationRuntime,                   // Handle to the runtime for sending messages
    // Channel now receives (sender_identity, message)
    message_rx: mpsc::Receiver<(TEEIdentity, RaftMessage)>,
    _message_tx: mpsc::Sender<(TEEIdentity, RaftMessage)>, // Keep sender to prevent channel closure
}

impl SimulatedTeeNode {
    /// Creates a new simulated TEE node.
    pub fn new(
        identity: TEEIdentity,
        secret_key: SecretKey,
        peers: Vec<TEEIdentity>, // Peers within the same shard
        config: SystemConfig,
        runtime: SimulationRuntime,
    ) -> Self {
        let storage = Box::new(InMemoryStorage::new()); // Each node gets its own storage
        let enclave = EnclaveSim::new(identity.id, Some(secret_key.clone()));
        let raft_node = RaftNode::new(identity.clone(), peers, config, storage, enclave);

        // Create a channel for this node to receive messages (now tuple)
        let (tx, rx): (mpsc::Sender<(TEEIdentity, RaftMessage)>, mpsc::Receiver<(TEEIdentity, RaftMessage)>) = mpsc::channel(100);

        SimulatedTeeNode {
            identity,
            secret_key,
            raft_node,
            runtime,
            message_rx: rx,
            _message_tx: tx, // Store sender side
        }
    }

    /// Returns the sender channel for this node.
    pub fn get_message_sender(&self) -> mpsc::Sender<(TEEIdentity, RaftMessage)> {
        self._message_tx.clone()
    }


    /// Starts the node's main event loop in a separate Tokio task.
    pub async fn run(mut self) {
         println!("[Node {}] Starting run loop...", self.identity.id);
        // Example: Tick Raft periodically
        let tick_duration = Duration::from_millis(50); // Adjust as needed
        let mut tick_timer = interval(tick_duration);

        loop {
            tokio::select! {
                _ = tick_timer.tick() => {
                    // println!("[Node {}] Tick", self.identity.id);
                    let events = self.raft_node.tick();
                    self.handle_raft_events(events).await;
                }
                // Receive tuple (sender_identity, message)
                Some((sender_identity, message)) = self.message_rx.recv() => {
                     println!("[Node {}] Received message from {}: {:?}", self.identity.id, sender_identity.id, message);
                    // Pass both sender and message to handle_message
                    let events = self.raft_node.handle_message(sender_identity, message);
                     self.handle_raft_events(events).await;
                }
                else => {
                    // Channel closed or other condition, break the loop
                    println!("[Node {}] Message channel closed or select! completed. Stopping run loop.", self.identity.id);
                    break;
                }
            }
        }
    }

    /// Processes events generated by the RaftNode.
    async fn handle_raft_events(&mut self, events: Vec<RaftEvent>) {
        for event in events {
            match event {
                RaftEvent::SendMessage(target_identity, message) => {
                    // Use runtime to send the message
                    self.runtime.route_message(self.identity.clone(), target_identity.id, message).await;
                }
                RaftEvent::BroadcastMessage(message) => {
                    // Use runtime to broadcast the message
                    println!("[Node {}] Broadcasting message: {:?}", self.identity.id, message);
                    self.runtime.broadcast_message(self.identity.clone(), message).await;
                }
                RaftEvent::ApplyToStateMachine(commands) => {
                    // This is where shard-specific application logic is triggered
                     println!("[Node {}] Applying commands: {:?}", self.identity.id, commands);
                    self.process_state_machine_commands(commands).await;
                }
                RaftEvent::Noop => {}
            }
        }
    }

    /// Placeholder function to process commands applied to the state machine.
    async fn process_state_machine_commands(&mut self, commands: Vec<crate::raft::state::Command>) {
        // In a real implementation, this would involve:
        // 1. Updating local shard state based on the command.
        // 2. Interacting with the TEE enclave (self.raft_node.enclave) if needed.
        // 3. Potentially generating messages/events for other system components (e.g., coordinator).
        for command in commands {
            println!("[Node {}][StateMachine] Processing command: {:?}", self.identity.id, command);
            // Example: If command requires a signature share, generate and send it
            // if let crate::raft::state::Command::GenerateSignatureShare(data_to_sign) = command {
            //     let signature = self.raft_node.enclave.sign_message(&data_to_sign);
            //     let share = /* construct SignatureShare */;
            //     // Send share to Coordinator via runtime
            //     // self.runtime.send_signature_share_to_coordinator(share).await;
            // }
        }
    }

    // Add methods for application-specific logic if needed
    // e.g., fn process_command(command: Command) -> Result<Option<SignatureShare>, Error>
} 